{
    "docs": [
        {
            "location": "/",
            "text": "You just arrived to the site maintained by Daniel Hnyk. This site should provide practical example how to set up your Linux server from scratch. No deep knowledge is necessary and you shouldn't need to know anything more except typing commands into bash shell.\n\n\nPurpose\n\n\nI enjoy programming and about two years ago it was obvious that I could get a lot from having my own server used for various uses like:\n\n\n\n\nWeb server - hosting webpages which I build in Django, Rails, Nodejs or plain HTML\n\n\nProxy - sometimes it's quite handy to have your own proxy for security or getting to national pages while abroad\n\n\nBackups - ever needed to push quickly some confidential file and didn't want to let Dropbox admins to look at it?\n\n\nSharing files - quickly and securely share files with your friends, family or just different computers.\n\n\nOpening sessions - using SSH tunneling you could let your connection open even if you are behind several routing points\n\n\nLong term jobs - periodically running some script (e.g. scrapping info from some website) or automating some repetitive task (e.g. backup).\n\n\n\n\nEven though today out-of-box Linux distributions have quite good security, using all these technologies necessary brings some risk of attack against your server. Hence, it's crucial to know about vulnerabilities and try to defend yourself against possible attacks. I will try to give you examples of such cases and reason why you should apply according policy.\n\n\nUsed software\n\n\nAs you could read in the header, as an operational system is chosen Linux. My working station is going to be Raspberry Pi with Arch Linux ARM distribution. Arch Linux is bleeding edge distribution which in nutshell means that we are going to use the most up-to-date technologies to this date (late 2015). Even though or examples are given for this specific Linux distribution it's good to mention that most of commands should be easily done even on other distributions. For example, package \nsystemd\n is \nused in all major distributions\n and hence you should be able to use it any where.\n\n\nI am not going to go into much details around Linux environment, since I've already done so in \nother tutorial\n. Some parts of this tutorial are going to overlap a bit (like domains and IPs) and in that case I will simply copy the text here with necessary updates. \n\n\nWhat you should have before\n\n\n\n\ninstalled Linux distribution of your choice with root access to the shell (direct by connecting peripherals or indirect using e.g. SSH)\n\n\nInternet connection. In this guide we are going to assume the most common setup for servers - you are connected by Ethernet to your router which is connected to wall socket.\n\n\napproximately 2 hours of time\n\n\n\n\nWhat are we going to cover\n\n\nThis guide is going to provide step-by-step solutions which cover:\n\n\n\n\nUsers, sandboxing their environment from others (and mainly from root's), storing passwords\n\n\nGeneral recommendations about installed software, controlling services, network settings, port forwarding\n\n\nSSH and keys, SSH guard service, firewall using \niptables\n, SSL\n\n\nEntropy used for encrypting and its sources\n\n\nInstalling and securing web server \nnginx\n, sandboxing websites folders",
            "title": "Home"
        },
        {
            "location": "/#purpose",
            "text": "I enjoy programming and about two years ago it was obvious that I could get a lot from having my own server used for various uses like:   Web server - hosting webpages which I build in Django, Rails, Nodejs or plain HTML  Proxy - sometimes it's quite handy to have your own proxy for security or getting to national pages while abroad  Backups - ever needed to push quickly some confidential file and didn't want to let Dropbox admins to look at it?  Sharing files - quickly and securely share files with your friends, family or just different computers.  Opening sessions - using SSH tunneling you could let your connection open even if you are behind several routing points  Long term jobs - periodically running some script (e.g. scrapping info from some website) or automating some repetitive task (e.g. backup).   Even though today out-of-box Linux distributions have quite good security, using all these technologies necessary brings some risk of attack against your server. Hence, it's crucial to know about vulnerabilities and try to defend yourself against possible attacks. I will try to give you examples of such cases and reason why you should apply according policy.",
            "title": "Purpose"
        },
        {
            "location": "/#used-software",
            "text": "As you could read in the header, as an operational system is chosen Linux. My working station is going to be Raspberry Pi with Arch Linux ARM distribution. Arch Linux is bleeding edge distribution which in nutshell means that we are going to use the most up-to-date technologies to this date (late 2015). Even though or examples are given for this specific Linux distribution it's good to mention that most of commands should be easily done even on other distributions. For example, package  systemd  is  used in all major distributions  and hence you should be able to use it any where.  I am not going to go into much details around Linux environment, since I've already done so in  other tutorial . Some parts of this tutorial are going to overlap a bit (like domains and IPs) and in that case I will simply copy the text here with necessary updates.",
            "title": "Used software"
        },
        {
            "location": "/#what-you-should-have-before",
            "text": "installed Linux distribution of your choice with root access to the shell (direct by connecting peripherals or indirect using e.g. SSH)  Internet connection. In this guide we are going to assume the most common setup for servers - you are connected by Ethernet to your router which is connected to wall socket.  approximately 2 hours of time",
            "title": "What you should have before"
        },
        {
            "location": "/#what-are-we-going-to-cover",
            "text": "This guide is going to provide step-by-step solutions which cover:   Users, sandboxing their environment from others (and mainly from root's), storing passwords  General recommendations about installed software, controlling services, network settings, port forwarding  SSH and keys, SSH guard service, firewall using  iptables , SSL  Entropy used for encrypting and its sources  Installing and securing web server  nginx , sandboxing websites folders",
            "title": "What are we going to cover"
        },
        {
            "location": "/users/",
            "text": "Users on Linux\n\n\nIt's necessary to elaborate a bit how users and permissions work on Linux systems. \n\n\nThe most important user present on every Linux distribution is the \nroot\n user, sometimes called as a \nsuperuser\n. This guy is the master and \ncan do basically everything. As a consequence of this\nfact is extermaly important to not let anyone get root access to your server since then he can do everything. \nIt's also quite dangerous work as a root all the time, since you can e.g. mistakenly erase your system partition\nand so on. For that we are going to create new user which will get the permissions only when he asks for them. \nFor this purpose we will use package called \nsudo\n (from \nsuperuser do\n).\n\n\nEvery file (and virtually \neverything\n is a file in Linux) specify permissions for owner, group and others.\nThere are three types of permissions: \nread\n, \nwrite\n and \nexecute\n. More about permissions can be found out\ne.g. \nhere\n. \n\n\nBefore that, we need to explain some theory from elementary security and cryptography.\n\n\nStoring passwords\n\n\nUsers are authenticated by passwords. We've learned from past that storing passwords cannot be done in plain text,\nsince when someone steal this text, he automatically gets access to all accounts listed there. For that reason we\n\nhash\n the passwords and store them in hashed form. Furthermore, the \nsalt\n is used while hashing. The file\nwith stored hashes is usually in \n/etc/passwd\n. \n\n\nFor changing a password for a current user \npasswd\n is used. Type \npasswd\n and change the main \nroot\n password to something reasonably strong.\nYou are not going to type this password a lot, since we are going to use other user for common system maintenance.\n\n\nSandboxing\n\n\nHere we just need to realize that you just don't want anyone to read some confidential file which don't belong to them\nor execute some malicious script. For this purpose there is an idea of \nsandboxing\n. That means\nthat we separate environments of different users - he could touch only what he creates and cannot touch anything\nwhich we don't explicitly allow. This scheme will be recurring once more when we will setting up e.g. web server.\n\n\nCreating a new user\n\n\nNow we need to install first necessary package. You have to be logged as the root and have internet connection. Update\nthe system by \npacman -Syu\n and then install \nsudo\n package by running \npacman -S sudo\n. \n\n\nWe now want to add regular user (think about it as a god who is creating humans). This can be done by: \nuseradd -m -G wheel Bob\n. It will create user called \u201cBob\u201d. There are also some other switches in command. \n-m\n is for creating bob\u2019s \nsandbox\n for his files in \n/home/bob\n and \n-G\n adds him to the \nwheel\n group. \n\n\nWhy? Remember that \nsudo\n can grant you superusers privileges. Every user who is in wheel group will have the ability to use \nsudo\n.  For that we need to \nedit \nsudo\n configuration file. Type: \nvisudo\n, find this line: \n# %wheel ALL=(ALL) ALL\n and delete \n#\n character (for future reference, this means to \u201cuncomment line\u201d). \nIt will look like this \n%wheel ALL=(ALL) ALL\n. Save and exit. We now need to set password for \nbob\n. Do it by typing \npasswd bob\n. From now you should be always working as a \nbob\n instead of \nroot\n. When you'll want to do something what only \nroot\n can do, e.g. \nthis_command\n, you'll have to type \nsudo this_command\n and insert \nbob\n's password (not the root one!). It's annoying, but save.",
            "title": "Users"
        },
        {
            "location": "/users/#users-on-linux",
            "text": "It's necessary to elaborate a bit how users and permissions work on Linux systems.   The most important user present on every Linux distribution is the  root  user, sometimes called as a  superuser . This guy is the master and \ncan do basically everything. As a consequence of this\nfact is extermaly important to not let anyone get root access to your server since then he can do everything. \nIt's also quite dangerous work as a root all the time, since you can e.g. mistakenly erase your system partition\nand so on. For that we are going to create new user which will get the permissions only when he asks for them. \nFor this purpose we will use package called  sudo  (from  superuser do ).  Every file (and virtually  everything  is a file in Linux) specify permissions for owner, group and others.\nThere are three types of permissions:  read ,  write  and  execute . More about permissions can be found out\ne.g.  here .   Before that, we need to explain some theory from elementary security and cryptography.",
            "title": "Users on Linux"
        },
        {
            "location": "/users/#storing-passwords",
            "text": "Users are authenticated by passwords. We've learned from past that storing passwords cannot be done in plain text,\nsince when someone steal this text, he automatically gets access to all accounts listed there. For that reason we hash  the passwords and store them in hashed form. Furthermore, the  salt  is used while hashing. The file\nwith stored hashes is usually in  /etc/passwd .   For changing a password for a current user  passwd  is used. Type  passwd  and change the main  root  password to something reasonably strong.\nYou are not going to type this password a lot, since we are going to use other user for common system maintenance.",
            "title": "Storing passwords"
        },
        {
            "location": "/users/#sandboxing",
            "text": "Here we just need to realize that you just don't want anyone to read some confidential file which don't belong to them\nor execute some malicious script. For this purpose there is an idea of  sandboxing . That means\nthat we separate environments of different users - he could touch only what he creates and cannot touch anything\nwhich we don't explicitly allow. This scheme will be recurring once more when we will setting up e.g. web server.",
            "title": "Sandboxing"
        },
        {
            "location": "/users/#creating-a-new-user",
            "text": "Now we need to install first necessary package. You have to be logged as the root and have internet connection. Update\nthe system by  pacman -Syu  and then install  sudo  package by running  pacman -S sudo .   We now want to add regular user (think about it as a god who is creating humans). This can be done by:  useradd -m -G wheel Bob . It will create user called \u201cBob\u201d. There are also some other switches in command.  -m  is for creating bob\u2019s  sandbox  for his files in  /home/bob  and  -G  adds him to the  wheel  group.   Why? Remember that  sudo  can grant you superusers privileges. Every user who is in wheel group will have the ability to use  sudo .  For that we need to \nedit  sudo  configuration file. Type:  visudo , find this line:  # %wheel ALL=(ALL) ALL  and delete  #  character (for future reference, this means to \u201cuncomment line\u201d). \nIt will look like this  %wheel ALL=(ALL) ALL . Save and exit. We now need to set password for  bob . Do it by typing  passwd bob . From now you should be always working as a  bob  instead of  root . When you'll want to do something what only  root  can do, e.g.  this_command , you'll have to type  sudo this_command  and insert  bob 's password (not the root one!). It's annoying, but save.",
            "title": "Creating a new user"
        },
        {
            "location": "/general/",
            "text": "Now some general but serious recommendations and system administration tasks. \n\n\nMaintaining the packages\n\n\nEvery Linux distribution comes with package manager. Arch Linux has \npacman\n and we've already\nused that in the previous chapter. This is used for managing for installing virtually all \nsoftware you are going to use.  \n\n\nKeep number of installed packages low\n\n\nLess software usually means less maintenance resources, less space used and lower risk of attack. \nWhen you get lost in your folder structure and lost track of installed software (what does what), how can you\nbe sure that you are not a \nhappy\n user of some Trojan or malware? Programs might also have bugs which might\nbe exploited by attacker to get into your system. It get us to another aspect. What \nlow\n means? Of course\nit can be exactly specified and it doesn't depend on your specific usage - the magical number\nusing bleeding edge astrology approaches says...\n\n\n...262 packages! That's exactly what I have on my system and that is still quite manageable.\n\n\nUp-to-date system\n\n\nMaintainers are usually hard working on patching their applications while the security\nholes are reported. For that reason is absolutely necessary to use up-to-date software on your system.\nOn Arch Linux you use \npacman -Syu\n to keep your system updated. \n\n\nAlso try to know about development of security critical packages. Is a development active? If their \ngithub repository shows last commit 5 years ago and number of reported issues is increasing, run!\n\n\nManaging services\n\n\nSometimes referred as daemons, these workhorses are usually running at background. For example in next chapter we will use SSH - it will run at background. Services are (on modern systems) managed by \ncontroversial\n service manager  \nsystemd\n.  \nsystemd\n is controlled by \nsystemctl\n (besides other, now irrelevant commands). To start some program, which is in this context called service (and we will stick to that), just run \nsystemctl start <unit>\n. There are other useful (and that\u2019s 90% of what you need to know about \nsystemctl\n) commands (all starts with systemctl and ends with \ndesired_unit\n - watch example):\n\n\n\n\nenable\n - this allow to run service after boot (but it will not start immediately)\n\n\ndisable\n - this will make device not to start after boot\n\n\nstart\n - this will immediately start a service (but will not enable it - it won\u2019t be run after boot)\n\n\nstop\n - stop service immediately (but not disable)\n\n\nstatus\n - this will print out all information in pretty format - you can find if it is enabled, started, if there are any errors etc.\n\n\n\n\nExample\n\n\nThere is service, which takes care about connection to network. We will play with that for a minute now. It\u2019s called \nsystemd-networkd\n. Try to start it, enable it, disable it and then stop it and get status to see what every command does by trying these:\n\n\n$ systemctl start systemd-networkd\n$ systemctl status systemd-networkd\n$ systemctl enable systemd-networkd\n$ systemctl status systemd-networkd\n$ systemctl disable systemd-networkd\n$ systemctl status systemd-networkd\n$ systemctl stop systemd-networkd\n\n\n\n\nLast thing you need to know about \nsystemd\n for our guide is where these services has it\u2019s own configuration files. They are stored either in \n/usr/lib/systemd/system/\n or \n/etc/systemd/system\n. For example, I\u2019ve noticed SSH service. Configuration file for this service is in \n/usr/lib/systemd/system/sshd.service\n. You can type \nsystemctl cat sshd\n to see what is inside and of course it can be edited.\n\n\nKeep number of running services low\n\n\nAs in previous part with packages, try to keep number of running services low for the same reasons. It's easier to keep track what is \nnow happening on your server, takes less resources and cannot be used for attacks and forgery. How many is \nlow number\n? I have 14.\n\n\nNetwork settings\n\n\nFor following chapters is essential to have your network connection set up correctly. First of all we have to assure that you are going to have\nstill the same IP address. IP address isn't nothing else then just 4 numbers separated by dot and its purpose is same as the number of your room in your\nhouse. Why room of the house and not the address of house itself? Well, your house has also IP which in general differs from the one your computer has inside the house. \nMore about local and public IPs can be read \nhere\n. \n\n\nLet's assume you are connected using ethernet connection. After connection RPi to the ethernet port in your router, the connection is usually established automatically and your router assigned your RPi by some pseudorandom IP address.To see what IP you are currently assigned can be done by \nip addr\n. The output should be something like:\n\n\n1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default \n    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\n    inet 127.0.0.1/8 scope host lo\n       valid_lft forever preferred_lft forever\n    inet6 ::1/128 scope host \n       valid_lft forever preferred_lft forever\n2: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000\n    link/ether b8:27:eb:2d:25:18 brd ff:ff:ff:ff:ff:ff\n    inet 192.168.0.201/24 brd 192.168.0.255 scope global eth0\n       valid_lft forever preferred_lft forever\n    inet6 fe80::ba27:ebff:fe2d:2518/64 scope link \n       valid_lft forever preferred_lft forever\n\n\n\n\neth0\n is ethernet connection and you can notice that my current IP is \n192.168.0.201\n.\n\n\nWe want to make this IP address static - it won't change if you unplug and plug again your device.  And how to choose static address? As you know your router is assigning IP address automatically (it is called DHCP). But not randomly in full range. It has some range of IP addresses which it can assign. Standard IP address of router is usually \n192.168.0.1\n and then assign addresses from \n192.168.0.2\n to \n192.168.0.254\n. Second standard is \n10.0.0.138\n for router and then it assigns addresses from \n10.0.0.139\n to \n10.0.0.254\n. But it can be anything else.\n\n\nI suggest to set one the address on the end from this range. You can notice, that my \neth0\n has IP address \n192.168.0.201\n.\n\n\nOpen or create a file \n/etc/systemd/network/ethernet_static.network\n and paste this:\n\n\n[Match]\nName=eth0\n\n[Network]\nAddress=the.static.address.rpi/24\nGateway=your.router.ip.address\n\n\n\n\nmy case:\n\n\n[Match]\nName=eth0\n\n[Network]\nAddress=192.168.0.111/24\nGateway=192.168.0.1\n\n\n\n\nNow you need to remove old non-static default profile \n/etc/systemd/network/eth0.network\n. Move it to your home folder so you can revert changes if something doesn't work.",
            "title": "Software"
        },
        {
            "location": "/general/#maintaining-the-packages",
            "text": "Every Linux distribution comes with package manager. Arch Linux has  pacman  and we've already\nused that in the previous chapter. This is used for managing for installing virtually all \nsoftware you are going to use.",
            "title": "Maintaining the packages"
        },
        {
            "location": "/general/#keep-number-of-installed-packages-low",
            "text": "Less software usually means less maintenance resources, less space used and lower risk of attack. \nWhen you get lost in your folder structure and lost track of installed software (what does what), how can you\nbe sure that you are not a  happy  user of some Trojan or malware? Programs might also have bugs which might\nbe exploited by attacker to get into your system. It get us to another aspect. What  low  means? Of course\nit can be exactly specified and it doesn't depend on your specific usage - the magical number\nusing bleeding edge astrology approaches says...  ...262 packages! That's exactly what I have on my system and that is still quite manageable.",
            "title": "Keep number of installed packages low"
        },
        {
            "location": "/general/#up-to-date-system",
            "text": "Maintainers are usually hard working on patching their applications while the security\nholes are reported. For that reason is absolutely necessary to use up-to-date software on your system.\nOn Arch Linux you use  pacman -Syu  to keep your system updated.   Also try to know about development of security critical packages. Is a development active? If their \ngithub repository shows last commit 5 years ago and number of reported issues is increasing, run!",
            "title": "Up-to-date system"
        },
        {
            "location": "/general/#managing-services",
            "text": "Sometimes referred as daemons, these workhorses are usually running at background. For example in next chapter we will use SSH - it will run at background. Services are (on modern systems) managed by  controversial  service manager   systemd .   systemd  is controlled by  systemctl  (besides other, now irrelevant commands). To start some program, which is in this context called service (and we will stick to that), just run  systemctl start <unit> . There are other useful (and that\u2019s 90% of what you need to know about  systemctl ) commands (all starts with systemctl and ends with  desired_unit  - watch example):   enable  - this allow to run service after boot (but it will not start immediately)  disable  - this will make device not to start after boot  start  - this will immediately start a service (but will not enable it - it won\u2019t be run after boot)  stop  - stop service immediately (but not disable)  status  - this will print out all information in pretty format - you can find if it is enabled, started, if there are any errors etc.",
            "title": "Managing services"
        },
        {
            "location": "/general/#example",
            "text": "There is service, which takes care about connection to network. We will play with that for a minute now. It\u2019s called  systemd-networkd . Try to start it, enable it, disable it and then stop it and get status to see what every command does by trying these:  $ systemctl start systemd-networkd\n$ systemctl status systemd-networkd\n$ systemctl enable systemd-networkd\n$ systemctl status systemd-networkd\n$ systemctl disable systemd-networkd\n$ systemctl status systemd-networkd\n$ systemctl stop systemd-networkd  Last thing you need to know about  systemd  for our guide is where these services has it\u2019s own configuration files. They are stored either in  /usr/lib/systemd/system/  or  /etc/systemd/system . For example, I\u2019ve noticed SSH service. Configuration file for this service is in  /usr/lib/systemd/system/sshd.service . You can type  systemctl cat sshd  to see what is inside and of course it can be edited.",
            "title": "Example"
        },
        {
            "location": "/general/#keep-number-of-running-services-low",
            "text": "As in previous part with packages, try to keep number of running services low for the same reasons. It's easier to keep track what is \nnow happening on your server, takes less resources and cannot be used for attacks and forgery. How many is  low number ? I have 14.",
            "title": "Keep number of running services low"
        },
        {
            "location": "/general/#network-settings",
            "text": "For following chapters is essential to have your network connection set up correctly. First of all we have to assure that you are going to have\nstill the same IP address. IP address isn't nothing else then just 4 numbers separated by dot and its purpose is same as the number of your room in your\nhouse. Why room of the house and not the address of house itself? Well, your house has also IP which in general differs from the one your computer has inside the house. \nMore about local and public IPs can be read  here .   Let's assume you are connected using ethernet connection. After connection RPi to the ethernet port in your router, the connection is usually established automatically and your router assigned your RPi by some pseudorandom IP address.To see what IP you are currently assigned can be done by  ip addr . The output should be something like:  1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default \n    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\n    inet 127.0.0.1/8 scope host lo\n       valid_lft forever preferred_lft forever\n    inet6 ::1/128 scope host \n       valid_lft forever preferred_lft forever\n2: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000\n    link/ether b8:27:eb:2d:25:18 brd ff:ff:ff:ff:ff:ff\n    inet 192.168.0.201/24 brd 192.168.0.255 scope global eth0\n       valid_lft forever preferred_lft forever\n    inet6 fe80::ba27:ebff:fe2d:2518/64 scope link \n       valid_lft forever preferred_lft forever  eth0  is ethernet connection and you can notice that my current IP is  192.168.0.201 .  We want to make this IP address static - it won't change if you unplug and plug again your device.  And how to choose static address? As you know your router is assigning IP address automatically (it is called DHCP). But not randomly in full range. It has some range of IP addresses which it can assign. Standard IP address of router is usually  192.168.0.1  and then assign addresses from  192.168.0.2  to  192.168.0.254 . Second standard is  10.0.0.138  for router and then it assigns addresses from  10.0.0.139  to  10.0.0.254 . But it can be anything else.  I suggest to set one the address on the end from this range. You can notice, that my  eth0  has IP address  192.168.0.201 .  Open or create a file  /etc/systemd/network/ethernet_static.network  and paste this:  [Match]\nName=eth0\n\n[Network]\nAddress=the.static.address.rpi/24\nGateway=your.router.ip.address  my case:  [Match]\nName=eth0\n\n[Network]\nAddress=192.168.0.111/24\nGateway=192.168.0.1  Now you need to remove old non-static default profile  /etc/systemd/network/eth0.network . Move it to your home folder so you can revert changes if something doesn't work.",
            "title": "Network settings"
        },
        {
            "location": "/ssh/",
            "text": "The most common way how to connect to your server is using \nSSH\n. \n\n\nWe will open RPi to world and in that case we need to secure it a bit. Service, which takes care about SSH is called \nsshd\n. \nWhere\n is it? It is run by \nsystemd\n, so \nsystemctl status sshd\n will show you more info. To reduce the brutal force attacks on root account (if was thousands of attempts every day on my little unimportant server), we will disable root login through SSH. \n\n\nTweaking SSH\n\n\nIf you haven't installed SSH yet, do it by \npacman -S ssh\n.\n\n\nOpen the file \n/etc/ssh/sshd_config\n and edit/uncomment or add these lines as follows (left the rest untouched):\n\n\nPort 1234\nPermitRootLogin no\nPubkeyAuthentication yes\n\n\n\n\nRestart \nssh\n service by \nsystemctl restart sshd\n. Since now, you cannot login as a root by ssh and that's good. Also - we changed the port of ssh to \n1234\n (you are advised to change this number to something different of course). Think about \nport\n as a tunnel, which is used by some application. There are about 60 thousands of them and you can choose whichever you want. Default port for SSH is 22 and that is the port which is most widely abused by brutal force attacks. Changing it to something from this range just makes it several tenth thousands harder to guess the access... \n\n\nSince now, using only \nssh bob@ipadress\n to connect to server is not enough. You will have to add port which should be used. \nssh -p 1234 bob@ip.address\n will do that for you.\n\n\nImproving the security of SSH can be done basically by two approaches depending on your needs.\n\n\nSSHguard\n\n\nShortly, \nsshguard\n is going to block recurring attempts of login and in case they are failing, it denies the access entirely for some specific time. Install it by \npacman -S sshguard\n. For proper usage, we need to tweak Linux firewall app called \niptables\n. \n\n\niptables\n\n\niptables\n are really just another layer of security often called as a firewall. It just specified what connections can come in and out. We need only simple configuration which can be done quite easily.\n\n\n$ iptables -F\n$ iptables -X\n$ iptables -P INPUT ACCEPT\n$ iptables -P FORWARD ACCEPT\n$ iptables -P OUTPUT ACCEPT\n$ iptables -N sshguard\n$ iptables -A INPUT -j sshguard \n$ iptables-save > /etc/iptables/iptables.rules    \n\n\n\n\nPersonally I stopped to use \nsshguard\n, since just changing port what SSH use was enough to reduce uninvited connections. Furthermore, there is actually a safer method using only SSH keys.\n\n\nSSH keys\n\n\nThis is the best you can do from the point of security. Open \n/etc/ssh/sshd_config\n and edit these lines as follows:\n\n\nChallengeResponseAuthentication no\nPasswordAuthentication no\nUsePAM no\n\n\n\n\nand again restart \nssh\n. We just disabled the ability to connect to your server with password. But how else to login in? Using \nkeys\n!\n\n\nCreating a key pair\n\n\nWe now need to create a key pair. Two files will with public and private key will be created. Let's do it by this command: \nssh-keygen -t ed25519 -f ~/.ssh/bobs_key\n (left passphrase empty).\n\nOne of created files is \n~/.ssh/bobs_key.pub\n and that is the one (public key) you want to transfer to client - the computer \nfrom\n you are going to connect to the server. \nThe second one is private key and you should never ever show any of the keys to anyone under any circumstances. It would basically imply your vulnerability, since anyone who possess public key and the username can connect to your server.\n\n\nCopy the content of the public key to the clients ssh folder. Now you need to specify this file to connect by \n-i\n switch following the filename, e.g. \nssh -p 1234 -i ~/.ssh/bobs_key.pub bob@yourrpiaddress\n. \n\n\nConvenient settings\n\n\nIt is annoying still typing same username, port and filepath to the key when we want to connect to our server. On PC from which we are connecting (no RPi), edit \n~/.ssh/config\n to this:\n\n\nHost my_superpc\n  HostName ipaddressofRPi\n  IdentityFile /home/yourusername/.ssh/name_of_identityfile\n  User bob\n  port 1234\n\n\n\n\nsince now, when you want to connect to RPi, you can just type \nssh my_superpc\n and it will take care about rest. Quite clever, isn't it?",
            "title": "SSH"
        },
        {
            "location": "/ssh/#tweaking-ssh",
            "text": "If you haven't installed SSH yet, do it by  pacman -S ssh .  Open the file  /etc/ssh/sshd_config  and edit/uncomment or add these lines as follows (left the rest untouched):  Port 1234\nPermitRootLogin no\nPubkeyAuthentication yes  Restart  ssh  service by  systemctl restart sshd . Since now, you cannot login as a root by ssh and that's good. Also - we changed the port of ssh to  1234  (you are advised to change this number to something different of course). Think about  port  as a tunnel, which is used by some application. There are about 60 thousands of them and you can choose whichever you want. Default port for SSH is 22 and that is the port which is most widely abused by brutal force attacks. Changing it to something from this range just makes it several tenth thousands harder to guess the access...   Since now, using only  ssh bob@ipadress  to connect to server is not enough. You will have to add port which should be used.  ssh -p 1234 bob@ip.address  will do that for you.  Improving the security of SSH can be done basically by two approaches depending on your needs.",
            "title": "Tweaking SSH"
        },
        {
            "location": "/ssh/#sshguard",
            "text": "Shortly,  sshguard  is going to block recurring attempts of login and in case they are failing, it denies the access entirely for some specific time. Install it by  pacman -S sshguard . For proper usage, we need to tweak Linux firewall app called  iptables .   iptables  iptables  are really just another layer of security often called as a firewall. It just specified what connections can come in and out. We need only simple configuration which can be done quite easily.  $ iptables -F\n$ iptables -X\n$ iptables -P INPUT ACCEPT\n$ iptables -P FORWARD ACCEPT\n$ iptables -P OUTPUT ACCEPT\n$ iptables -N sshguard\n$ iptables -A INPUT -j sshguard \n$ iptables-save > /etc/iptables/iptables.rules      Personally I stopped to use  sshguard , since just changing port what SSH use was enough to reduce uninvited connections. Furthermore, there is actually a safer method using only SSH keys.",
            "title": "SSHguard"
        },
        {
            "location": "/ssh/#ssh-keys",
            "text": "This is the best you can do from the point of security. Open  /etc/ssh/sshd_config  and edit these lines as follows:  ChallengeResponseAuthentication no\nPasswordAuthentication no\nUsePAM no  and again restart  ssh . We just disabled the ability to connect to your server with password. But how else to login in? Using  keys !  Creating a key pair  We now need to create a key pair. Two files will with public and private key will be created. Let's do it by this command:  ssh-keygen -t ed25519 -f ~/.ssh/bobs_key  (left passphrase empty). \nOne of created files is  ~/.ssh/bobs_key.pub  and that is the one (public key) you want to transfer to client - the computer  from  you are going to connect to the server. \nThe second one is private key and you should never ever show any of the keys to anyone under any circumstances. It would basically imply your vulnerability, since anyone who possess public key and the username can connect to your server.  Copy the content of the public key to the clients ssh folder. Now you need to specify this file to connect by  -i  switch following the filename, e.g.  ssh -p 1234 -i ~/.ssh/bobs_key.pub bob@yourrpiaddress .",
            "title": "SSH keys"
        },
        {
            "location": "/ssh/#convenient-settings",
            "text": "It is annoying still typing same username, port and filepath to the key when we want to connect to our server. On PC from which we are connecting (no RPi), edit  ~/.ssh/config  to this:  Host my_superpc\n  HostName ipaddressofRPi\n  IdentityFile /home/yourusername/.ssh/name_of_identityfile\n  User bob\n  port 1234  since now, when you want to connect to RPi, you can just type  ssh my_superpc  and it will take care about rest. Quite clever, isn't it?",
            "title": "Convenient settings"
        }
    ]
}